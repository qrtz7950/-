< 추상클래스(abstract) > ({abs01 - Usermain, Menu, LGPrinter, SamsungPrinter, Printer, HPPrinter})

	- 하나 이상의 추상메소드를 가지고 있는 클래스
	
	- abstract : 클래스, 메소드 (멤버변수x)
	
	- 코드 유지, 보수 시 편의를 위해 강제적으로 상속시 필요한 메소드명, 매개변수명을 정해주기 위해 생긴 개념
	
		(변경이 있을것 같은 클래스는 추상클래스를 상속하여 사용하게 함)
	
	
	
	* 추상클래스
		
		- abstract를 클래스 선언 부분에 추가함
	
	* 추상메소드

		- abstract를 메소드 선언 부분에 추가함
		
	★	- 메소드의 선언부만 있고 바디({}) 가 없음
	
	

	
	- 추상 메소드를 포함하는 클래스는 반드시 추상클래스로 선언되어야 함
	
	- 추상클래스는 인스턴스 생성이 불가능함(new키워드 사용불가)
	
	- 추상클래스는 일반(구현된) 메소드와 추상 메소드 모두 선언이 가능함
	
	- 추상클래스를 상속받는 하위클래스는 상위클래스의 추상 메소드를 반드시 오버라이딩(재정의) 해야 한다
	
	- 추상클래스의 객체변수는 하위클래스를 이용함

-----------------------------------------------------------------------------------------------------------------------------

* AmaterasUML

	Help -> Install New Software -> Work with(밑 주소 입력)

	http://takezoe.github.io/amateras-update-site

-----------------------------------------------------------------------------------------------------------------------------

< 객체의 형변환 > ({abs01}, {cast - CastMain01, Parent, Child01, Child02, CastMain02})

	- 정의 : "="연산자를 기준으로 좌변과 우변의 데이터 타입이 다른 경우에 발생

	- 조건 : 좌변과 우변의 객체가 상속 관계가 있어야 함
	
	- 종류
		1. 묵시적 형변환

			- 상위(부모) 클래스 타입 = 하위(자식) 클래스 타입
					Parent p = new Child();

			- 부모타입은 자식타입을 포함

		★	- 형변환된 상위 클래스 변수가 사용 할 수 있는 범위는 자식클래스에서 상속된 부분까지만 됨

		★★	- 단, 상위클래스의 메소드가 하위클래스에서 오버라이딩(재정의)했을 경우 하위클래스에 정의된 메소드가 호출

		★★★	- 상속받은 하위클래스의 객체가 묵시적 형변환 됨을 이용하여 메소드의 인자를 부모클래스 객체의 형태로
			  매개변수를 통일 할 수 있다.

		
		2. 명시적 형변환

			- 하위(자식) 클래스 타입 = 상위(부모) 클래스 타입
					 Child c = (Child) p;
			
			- 주로 묵시적 형변환이 되어 있는 상태에서 사용 할 수 없는 부분까지 사용하기 위해 사용

-----------------------------------------------------------------------------------------------------------------------------

< 인터페이스 > ({inter - type01 -- UserMain, LGTV, SamsungTV}, {inter - type02 -- UserMain, TV, LGTV, SamsungTV})

	- 다중상속이 지원되지 않아 비슷한 기능을 하는 인터페이스 사용(클래스가 아님)
	
	- 추상 메소드, 상수들의 집합 (모든 메소드가 추상으로[abstract], 모든 변수가 상수로[public static final] 자동변환)
	
	- interface 키워드를 이용하여 선언
	
	- 선언되는 변수는 모두 상수로 적용
	
	- 객체 생성이 불가능
	
	- 클래스가 인터페이스 상속시 implements 사용 (인터페이스가 인터페이스 상속시 extends 사용)
	
	- 인터페이스 추상메소드는 하위클래스에서 오버라이딩(재정의) 해야 한다.(오버라이딩 시 public으로 해야됨)

	- 인터페이스 객체변수는 하위클래스를 이용

		interface Printer{ }
		class LGPrinter implements Printer{ }
		---------------------------------------------------
		class Main{
			public static void main(String[] args){
				Printer p = new LGPrinter();
			}
		}

-----------------------------------------------------------------------------------------------------------------------------

< 추상클래스 + 인터페이스 >

	보통 사용 모양
	
	interface A{ }
	interface B{ }

	abstract class CAB implements A, B {
	}

	class D extends CAB{

		CAB obj = new CAB();

		A obj = new CAB();
		B obj = new CAB();
	}