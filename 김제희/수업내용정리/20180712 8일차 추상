1교시

유연성을 위해 상속을 사용한다

추상 클래스는 프로그램 작성 시 변화에 둔감한 프로그램을 만들기 위해서 상속이 강제되는 클래스가 추상클래스다

일종의 양식을 만드는 것

추상클래스에는 바디가 없이 메소드의 정의만 되어 있다 단지 형식만 정해져 있는것이다

그래서 추상 클래스 그 자체로는 객체를 생성할 수 없기때문에 추상 클래스를 상속한 sub클래스를 만들어서 오버 라이딩 해야한다

오버라이딩은 단지 추상클래스와 서브 클래스간의 관계에서만 있는것은 아니지만 추상클래스를 이용하여 오버라이딩을 강제한다

※오버라이딩 : 
부모클래스에서 상속받은 서브 클래스의 메소드의 기능을 바꾸거나
상속받은 부모 클래스가 추상 클래스일 경우 메소드의 기능을 구현하는것

추상클래스를 상속받은 서브클래스의 경우에는

추상클래스의 객체변수는 하위클래스로 가질수있다

부모 클래스 Print 서브클래스 LgPrinter일 때 LGprinter의 객체를 만들고 싶다

Printer p = new LgPrinter();
LgPrinter p = new LgPrinter();

둘다 가능하다 기능은 조금 다르다 그건 나중에

------------------------------------------------------------------------------------------
5교시

객체지향언어의 특징

자바 병신이야 C#으로 해야지
자바로 만든 클래스가 어떤 특징을 가지고 있는가?
이것을 표현하기 위해서 누구나 봐도 알아볼수있는 객체를 표현해 모델링을 하고 싶었다
이거시바로 uml

C++ C#은 star uml을 사용하나 자바는 연동이 안됨

아마테라스를 이용 uml작성 예제 실습

------------------------------------------------------------------------------------------
6교시

객체형변환
1. 정의 : "=" 연산자를 기준으로 좌변과 우변의 데이터 타입이 다른 경우에 발생
2. 조건 : 좌변과 우변의 객체가 상속 관계가 있어야 함

객체형변환을 이용하면 좀더 둔감한 코드를 작성할 수 있고
최종적으로 추상 클래스와 객체형 변환을 같이써야 완전 둔감한 프로그램을 만들 수 있다

상속관계에 있는 두 클래스를 객체를 

형변환할 때 큰 타입을 작은 타입으로 변환하면 다운캐스팅 (묵시형 객체 형변환)
형변환할 때 작은 타입을 큰 타입으로 변환하면 업캐스팅 (명시형 객체 형변환)

상속을 받아 상위 클래스 하위 클래스 인스턴트 객체가 모두 있는 하나의 인스턴트 객체에서
묵시적 객체형변환으로 Printer p = new LGPrinter ( );하면 더 큰 타입을 작은 타입으로 변환하는 묵시형 형변환이 일어난다.

이 경우 Print형 인스턴트 객체 p가 상속받은 상위 클래스의 Print에 정의된 멤버변수와 메소드만 사용할 수 있다.
그렇지만 이 둘은 상속관계이기때문에 p.info()로 메소드를 호출하게되면 하위 클래스에 오버라이딩된 메소드가 호출된다
교재 106번째 슬라이드 참조

결국 부모형 객체 변수로 하위 메소드를 이용할 수 있다는 장점이 있다
자식형 객체변수를 사용하지 않음으로 코드에 사용되는 메소드들의 변수를 통일할 수 있다

묵시형 명시형변환 예제

----------------------------------------------------------------------------------------------
7교시

객체지향적 프로그래밍을 하다보니 여러 클래스들의 메소드들이 동시에 필요한 객체를 만들어야했지만
상속은 한개의 클래스만 가능하기때문에 (단일 상속) 추상메소드들의 집합인 인터페이스가 등장했다.

인터페이스 추상메소드들의 집함
들어갈수 있는것은 추상메소드와 상수

인터페이스는 객체를 추상화시키는 것이 아니라 기능을 

선언하는 모든 메소드는 추상메소드로

변수는 모드 자동형변환으로 public stataic final 이 붙은 상수로 자동 변환된다

다른 타입일 경우에는 임플리먼츠
같은 타입일 경우에는 익스텐드

class -> class            //extend
implements -> class       //implements
implements -> implements  //extend

인터페이스도 추상 메소드의 집합이기 때문에 이것 또한 강제성을 지닌다.

